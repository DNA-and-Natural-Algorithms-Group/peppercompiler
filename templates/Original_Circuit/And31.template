declare And31(t, di1, di2, di3, do, c, end): x + y + z -> out(OUT)

sequence tx = ?N : <t>
sequence dx = S ?N S : <di1>
sequence ty = ?N : <t>
sequence dy = S ?N S : <di2>
sequence tz = ?N : <t>
sequence dz = S ?N S : <di3>
sequence toe_out = ?N : <t>
sequence data_out = S ?N S : <do>

sequence x = tx dx : <t+di1>
sequence y = dy ty : <t+di2>
sequence z = tz dz : <t+di3>
sequence out = toe_out data_out : <t+do>

strand inX = x : <t+di1>
strand inY = y : <t+di2>
strand inZ = z : <t+di3>

strand X = ?N : <t+di1>
strand Y = ?N : <di1+di2>
strand Z = ?N : <di2+di3>
strand Out = ?N out S <end-1>N : <do+(di3-c)>

## Structures
struct InX = inX : U<t+di1>
struct InY = inY : U<t+di2>
struct InZ = inX : U<t+di3>

struct Gate = Y + Out + Z + X : H<di1>(H<di2>(+ H<di3-end>(U<do-c> H<end>(+))) +) U<t>
struct Gate_inter1 = Y + Out + Z : U<di1> H<di2>(+ H<di3-end>(U<do-c> H<end>(+)))
struct Gate_inter2 =     Out + Z :                 H<di3-end>(U<do-c> H<end>(+)) U<di2>

struct X_waste = inX + X : H<t+di1>(+)
struct Y_waste = inY + Y : H<t+di2>(+) U<di1-t>
struct Z_waste = inZ + Z : H<t+di3>(+) U<di2-t>

struct OUT = Out : U<do+(di3-c)>

kin InX + Gate -> X_waste + Gate_inter1
kin InY + Gate_inter1 -> Y_waste + Gate_inter2
kin InZ + Gate_inter2 -> Z_waste + OUT

